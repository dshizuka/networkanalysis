---
title: "5. Measuring Networks"
author: "Dai Shizuka"
date: "7/11/2018"
output: 
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: false
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(fig.width=4, fig.height=3.5, message=F) 

```

```{r echo=FALSE}
set.seed(2)
```
-------

Now that we have a handle on visualizing a network and the basics of relevant types of networks, we will go about the task of quantitatively describing its characteristics.
There are multiple levels at which we can measure and describe networks: 

* Node-level
* Subcomponent-level
* Networklevel

Let's start by loading the sample social network we introduced in [section 4.1](04.1_socialnetworks.html). Here, we are going to be using both the `igraph` and `asnipe` packages.

```{r, message=F, results='hide'}
library(asnipe)
library(igraph)
degree=igraph::degree
betweenness=igraph::betweenness
closeness=igraph::closeness
assoc=as.matrix(read.csv("https://dshizuka.github.io/networkanalysis/SampleData/Sample_association.csv", header=T, row.names=1))
gbi=t(assoc) 
mat=get_network(t(assoc), association_index="SRI") 
g=graph_from_adjacency_matrix(mat, "undirected", weighted=T) #create a graph object
```

```{r}
# plot the network
set.seed(10)
l=layout_with_fr(g)
plot(g, layout=l, vertex.label="", vertex.color="gold", edge.color="slateblue", edge.width=E(g)$weight*5)
```

##5.1 Centrality Measures (i.e., node-level measures)

Centrality is a general term that relates to measures of a node’s position in the network. There are many such centrality measures, and it can be a daunting task to wade through all of the different ways to measure a node’s importance in the network. Here, we will introduce just a few examples.

###5.1.1 Degree and Strength
Let’s start with the most straight-forward centrality metric: **degree centrality**. Degree centrality is simply the *number of edges connected to a given node*. In a social network, this might mean the number of friends an individual has. We can calculate degree centrality with a simple function:

```{r}
degree(g)
```

Let’s visualize what this means by varying the node sizes proportional to degree centrality.

```{r}
set.seed(10)
de=igraph::degree(g)
plot(g, vertex.label="", vertex.color="gold", edge.color="slateblue", vertex.size=de*2, edge.width=E(g)$weight*5)
```

In weighted networks, we can also **node strength**, which is the sum of the weights of edges connected to the node. Let’s calculate node strength and plot the node sizes as proportional to these values.

```{r}
set.seed(10)
st=graph.strength(g)
plot(g,  vertex.label="", vertex.color="gold", edge.color="slateblue", edge.width=E(g)$weight*5, vertex.size=st*5)
```

Compare the relative node sizes when plotting by **degree** vs. **strength**. What differences do you notice?

### 5.1.2 Betweenness

Let’s now do the same for **betweenness centrality**, which is defined as *the number of geodesic paths (shortest paths) that go through a given node*. Nodes with high betweenness might be influential in a network if, for example, they capture the most amount of information flowing through the network because the information tends to flow through them. Here, we use the normalized version of betweenness.

```{r}
be=betweenness(g, normalized=T)
plot(g,  vertex.label="", vertex.color="gold", edge.color="slateblue", vertex.size=be*50, edge.width=E(g)$weight*5)
```

You can see that there are three nodes that have qualitatively higher betweenness values than all other nodes in the network. One way to interpret this is that these are nodes that tend to act as “bridges” between different clusters of nodes in the network (but of course, this is only sample data).

What does this say about the importance of these nodes? Well, that depends on the network and the questions--in particular how you might quantify ‘importance’ in your network.

Here’s a short list of some commonly-used centrality measures:

Centrality Measure | Function | Description |
--------------|----------|-----------------------------------|
degree  |`degree()`  |Number of edges connected to node|  
strength |`graph.strength()` |Sum of edge weights connected to a node (aka *weighted degree*)|
betweenness | `betweenness()` | Number of geodesic paths that go through a given node |
closeness | `closeness()` | Number of steps required to access every other node from a given node |
eigenvector centrality | `eigen_centrality()` | Values of the first eigenvector of the graph adjacency matrix. The values are high for vertices that are connected to many other vertices that are, in turn, connected many others, etc.|


### 5.1.3 Assembling a dataset of node-level measures
So now we know the basics of how to get centrality measures. For data analysis, we will likely want to measure and compare measures of node centrality with other traits. This will require putting together a dataframe that combines vertex attributes and centrality measures.

Let’s say we want to assemble a dataset of node centrality for our sparrow network. Let’s use the three centrality measures we already introduced:

```{r}
names=V(g)$name
de=degree(g)
st=graph.strength(g)
be=betweenness(g, normalized=T)


#assemble dataset
d=data.frame(node.name=names, degree=de, strength=st, betweenness=be) 
head(d) #display first 6 lines of data
```

Let's plot the relationship between degree and strength
```{r}
plot(strength~degree, data=d)
```

Obviously, these are correlated, since strength is simply the weighted version of degree. 

How about the relationship between betweenness and strength?

```{r}
plot(betweenness~strength, data=d)
```

These are not well correlated, since they describe something different...

##5.2 Network-level measures

Size and density
Let’s start by getting some basic information for the network, such as the number of nodes and edges. There are a couple of functions to help you extract this information without having to look it up in the "object summary" (e.g., `summary(g)`). Using these functions, you can store this information as separate objects, e.g., *n* for # nodes and *m* for # edges.

```{r}
n=vcount(g)
m=ecount(g)
n
m
```

Since we now have the network size and the number of edges, we can calculate the density of the network. The definition of network density is:

density = [# edges that exist] / [# edges that are possible]

In an undirected network with no loops, the number of edges that are possible is exactly the number of dyads that exist in the network. In turn, the number of dyads is $\frac {n(n−1)}{2}$ where *n* = number of nodes. Withthis information, we can calculate the density with the following:

```{r}
dyads=n*(n-1)/2
density=m/dyads
density
```


Of course, there is a pre-packaged function for calculating density, called `edge_density()`:

```{r}
edge_density(g)
```