<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>2.Data Formats for Networks</title>

<script src="site_libs/header-attrs-2.16/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Network Analysis in R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
<li>
  <a href="tutorials.html">Tutorials</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">2.Data Formats for Networks</h1>
<h4 class="date">updated 01/05/23</h4>

</div>


<hr />
<p>##2.1 Basic Data Formats For Networks</p>
<p>There are three basic data formats that can be used to describe
networks: <em>adjacency matrix</em>, <em>edge list</em>, and
<em>adjacency list</em>. Each format has its pros and cons. There are
other variations on these (e.g., a <em>biadjacency matrix</em> for
bipartite networks).</p>
<p>###2.1.1 Adjacency Matrix</p>
<p>An <strong><em>adjacency matrix</em></strong> is a matrix in which
the rows and columns represent different nodes. In an unweighted
adjacency matrix, the edges (i.e., lines) are represented by 0 or 1,
with indicating that these two nodes are connected. If two nodes are
connected, they are said to be adjacent (hence the name, adjacency
matrix). In a weighted matrix, however, you can have different values,
indicating different edge qualities (or tie strengths).</p>
<p>Let’s start by loading the <code>igraph</code> package and setting up
a toy network (same as in <a href="01_intro.html">Lesson 1:
Intro</a>)</p>
<pre class="r"><code>library(igraph)
g=make_graph(~A-B-C-A, D-E-F-D, A-F) 
V(g)$color=c(&quot;white&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;orange&quot;, &quot;yellow&quot;)
E(g)$weight=1:7
E(g)$color=rainbow(7)</code></pre>
<p>We can now extract the adjacency matrix of the network we created,
called <code>g</code>:</p>
<pre class="r"><code>as_adjacency_matrix(g, sparse=F)</code></pre>
<pre><code>##   A B C D E F
## A 0 1 1 0 0 1
## B 1 0 1 0 0 0
## C 1 1 0 0 0 0
## D 0 0 0 0 1 1
## E 0 0 0 1 0 1
## F 1 0 0 1 1 0</code></pre>
<p><strong>Note the argument <code>sparse=F</code> in the code
above</strong>. This displays the adjacency matrix with 0s. If
<code>sparse=T</code>, the output is a special format of the matrix
where the 0s are replaced with a period (this is to make it easier to
see very large matrices).</p>
<p>Also note that, because the network is undirected and unweighted, the
corresponding adjacency matrix is symmetrical (value for row A, column B
is identical to row B, column A) and binary (values are 0 or 1).</p>
<p>###2.1.2 Edge List</p>
<p>An <strong>edge list</strong> is a two-column list of the two nodes
that are connected in a network. In the case of a directed network, the
convention is that the edge goes from the vertex in the first column to
the vertex in the second column. In an undirected network, the order of
the vertices don’t matter. For weighted networks, you may have a third
column that indicates the edge weight.</p>
<p>You can get the edgelist of any igraph object as well:</p>
<pre class="r"><code>as_edgelist(g)</code></pre>
<pre><code>##      [,1] [,2]
## [1,] &quot;A&quot;  &quot;B&quot; 
## [2,] &quot;A&quot;  &quot;C&quot; 
## [3,] &quot;A&quot;  &quot;F&quot; 
## [4,] &quot;B&quot;  &quot;C&quot; 
## [5,] &quot;D&quot;  &quot;E&quot; 
## [6,] &quot;D&quot;  &quot;F&quot; 
## [7,] &quot;E&quot;  &quot;F&quot;</code></pre>
<p>###2.1.3 Affiliation Matrix (aka individual-by-group matrix)</p>
<p>In many cases, we will construct social networks from co-membership
in groups. For example, we would draw edges between individuals based on
their patterns of co-occurrence in a flock. Similarly, we could
construct networks of species co-occurrences in populations, etc.</p>
<p>To do this, we would first need data in a matrix in which rows
represent individuals (or species) and columns represent groups (or
populations). Note that you could flip the columns and rows–either way
is fine. You just need to be aware of how you arranged it.</p>
<p>Here’s a toy example in which individuals A through E occur in
different combinations in 4 groups.</p>
<pre class="r"><code>A=c(1,1,0,0) 
B=c(1,0,1,0) 
C=c(1,0,1,0) 
D=c(0,1,0,1) 
E=c(0,0,1,1) 
aff=matrix(c(A,B,C,D,E),nrow=5,byrow=TRUE) 
dimnames(aff)=list(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;),c(&quot;Group1&quot;,&quot;Group2&quot;,&quot;Group3&quot;,&quot;Group4&quot;))
aff #The individual-by-group matrix</code></pre>
<pre><code>##   Group1 Group2 Group3 Group4
## A      1      1      0      0
## B      1      0      1      0
## C      1      0      1      0
## D      0      1      0      1
## E      0      0      1      1</code></pre>
<p>There are different ways to convert this data into a social
network–i.e., a network that describes which individual co-occurs with
which individual in groups. One simple way is to do what is called a
<em>one-mode projection</em> of this data by <strong>multiplying this
matrix with the transpose of itself</strong>. Note that matrix
multiplication notation is <code>%*%</code> in R.</p>
<pre class="r"><code>aff %*% t(aff)</code></pre>
<pre><code>##   A B C D E
## A 2 1 1 1 0
## B 1 2 2 0 1
## C 1 2 2 0 1
## D 1 0 0 2 1
## E 0 1 1 1 2</code></pre>
<p>This resulting matrix is now an adjacency matrix in which the
diagonal represents how many groups each individual participated in (2
for all of them), and the off-diagonals represent the number of times a
pair of individuals were int he same group. You can use this as the
adjacency matrix to convert this into a network:</p>
<pre class="r"><code>m2=aff %*% t(aff)
g2=graph_from_adjacency_matrix(m2, &quot;undirected&quot;, weighted=T, diag=F)
plot(g2, edge.width=E(g2)$weight)</code></pre>
<p><img src="02_dataformats_files/figure-html/unnamed-chunk-6-1.png" width="576" /></p>
<p>###2.1.4 Adjacency List</p>
<p>An <strong>adjacency list</strong>, also known as a node list,
presents the ‘focal’ node on the first column, and then all the other
nodes that are connected to it (i.e., adjacent to it) as columns to the
right of it. In a spreadsheet, would be a table with rows with different
number of columns, which is often very awkward to deal with, like
this:</p>
<table>
<thead>
<tr class="header">
<th>Focal Node</th>
<th>Neighbor_1</th>
<th>Neighbor_2</th>
<th>Neighbor_3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>B</td>
<td>C</td>
<td>F</td>
</tr>
<tr class="even">
<td>B</td>
<td>A</td>
<td>C</td>
<td></td>
</tr>
<tr class="odd">
<td>C</td>
<td>A</td>
<td>B</td>
<td></td>
</tr>
<tr class="even">
<td>D</td>
<td>E</td>
<td>F</td>
<td></td>
</tr>
<tr class="odd">
<td>E</td>
<td>D</td>
<td>F</td>
<td></td>
</tr>
<tr class="even">
<td>F</td>
<td>A</td>
<td>D</td>
<td>E</td>
</tr>
<tr class="odd">
<td>—</td>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
</tbody>
</table>
<p>In R, you can display an adjacency list as an actual ‘list object’,
with each item representing neighbors of each focal node:</p>
<pre class="r"><code>as_adj_list(g)</code></pre>
<pre><code>## $A
## + 3/6 vertices, named, from 956e4f0:
## [1] B C F
## 
## $B
## + 2/6 vertices, named, from 956e4f0:
## [1] A C
## 
## $C
## + 2/6 vertices, named, from 956e4f0:
## [1] A B
## 
## $D
## + 2/6 vertices, named, from 956e4f0:
## [1] E F
## 
## $E
## + 2/6 vertices, named, from 956e4f0:
## [1] D F
## 
## $F
## + 3/6 vertices, named, from 956e4f0:
## [1] A D E</code></pre>
<hr />
<p>##2.2 Data formats for directed and weighted networks Let’s consider
some important aspects of data formats that come with networks that are
directed or weighted. I will keep this short by listing some important
things to consider, and a line of code that will display this.</p>
<p>###2.2.1 Directed networks</p>
<p>Let’s create an igraph object for a <em>directed network</em> called
<code>dir.g</code>. For directed networks, the adjacency matrix is not
symmetrical. Rather, the cell value is 1 if the edge goes from the
<em>row vertex</em> to the <em>column vertex</em>.</p>
<pre class="r"><code>dir.g=make_graph(~A-+B-+C-+A, D-+E-+F-+D, A+-+F)
plot(dir.g)</code></pre>
<p><img src="02_dataformats_files/figure-html/unnamed-chunk-8-1.png" width="576" /></p>
<pre class="r"><code>as_adjacency_matrix(dir.g, sparse=F)</code></pre>
<pre><code>##   A B C D E F
## A 0 1 0 0 0 1
## B 0 0 1 0 0 0
## C 1 0 0 0 0 0
## D 0 0 0 0 1 0
## E 0 0 0 0 0 1
## F 1 0 0 1 0 0</code></pre>
<p>For directed networks with mutual edges (represented by double-edged
arrows), the edge list lists both directions separately:</p>
<pre class="r"><code>as_edgelist(dir.g)</code></pre>
<pre><code>##      [,1] [,2]
## [1,] &quot;A&quot;  &quot;B&quot; 
## [2,] &quot;A&quot;  &quot;F&quot; 
## [3,] &quot;B&quot;  &quot;C&quot; 
## [4,] &quot;C&quot;  &quot;A&quot; 
## [5,] &quot;D&quot;  &quot;E&quot; 
## [6,] &quot;E&quot;  &quot;F&quot; 
## [7,] &quot;F&quot;  &quot;A&quot; 
## [8,] &quot;F&quot;  &quot;D&quot;</code></pre>
<p>You can see that, since the <code>dir.g</code> network object
contains one mutual edge (A&lt;-&gt;F), the edge list has 8 rows, while
the edgelist for the undirected version of the network has 7 rows.</p>
<p>###2.2.1 Weighted networks Let’s now consider what the data formats
would look like. To do this, let’s go back to our original network,
<code>g</code>. Let’s say that the edge widths that we added represent
edge weights or values. Then, the adjacency matrix for this network can
be shown by using the <code>attr=</code> argument within the function to
call the adjacency matrix to specify the edge weights:</p>
<pre class="r"><code>as_adjacency_matrix(g, sparse=F, attr=&quot;weight&quot;)</code></pre>
<pre><code>##   A B C D E F
## A 0 1 2 0 0 3
## B 1 0 4 0 0 0
## C 2 4 0 0 0 0
## D 0 0 0 0 5 6
## E 0 0 0 5 0 7
## F 3 0 0 6 7 0</code></pre>
<p>You can display the edge weights as an edgelist as well. In fact,
<code>igraph</code> has a convenient function that will display all of
the edge attributes together as a data frame:</p>
<pre class="r"><code>as_data_frame(g)</code></pre>
<pre><code>##   from to weight   color
## 1    A  B      1 #FF0000
## 2    A  C      2 #FFDB00
## 3    A  F      3 #49FF00
## 4    B  C      4 #00FF92
## 5    D  E      5 #0092FF
## 6    D  F      6 #4900FF
## 7    E  F      7 #FF00DB</code></pre>
<p>Recall that in undirected networks, the “from” and “to” designation
are arbitrary (it is simply organized in alphabetical order here).</p>
<p>If you want to show an edge list as a three-column matrix with the
two nodes and edge weights only, you can just specify which edge
attribute you want to use as the edge weight, e.g.:</p>
<pre class="r"><code>as_data_frame(g)[,c(&quot;from&quot;, &quot;to&quot;, &quot;weight&quot;)]</code></pre>
<pre><code>##   from to weight
## 1    A  B      1
## 2    A  C      2
## 3    A  F      3
## 4    B  C      4
## 5    D  E      5
## 6    D  F      6
## 7    E  F      7</code></pre>
<hr />
<p>##2.3 Going from Data to Networks</p>
<p><br></p>
<p>###2.3.1 Creating a network from your edge list</p>
<p>Creating a network from an edgelist that you have created is easy.
First, import the .csv file called “sample_edgelist.csv”.</p>
<pre class="r"><code>edge.dat=read.csv(&quot;https://dshizuka.github.io/network2018/NetworkWorkshop_SampleData/sample_edgelist.csv&quot;) 
edge.dat</code></pre>
<pre><code>##        V1      V2 weight
## 1    Adam   Betty      1
## 2    Adam  Daniel      1
## 3    Adam   Frank      4
## 4   Betty Charles      3
## 5   Betty  Daniel      1
## 6   Betty   Frank      2
## 7  Daniel  Esther      1
## 8  Daniel   Frank      1
## 9  Esther   Frank      1
## 10  Frank    Gina      2</code></pre>
<p>So this data frame has three columns: the first two columns are the
edge list, and the third column is an edge value we called “weight”. If
we have the data organized this way, we can simply use a function called
<code>graph.data.frame()</code> to create a network we will call
<code>eg</code>.</p>
<pre class="r"><code>set.seed(2)
eg=graph_from_data_frame(edge.dat, directed=FALSE) 
eg</code></pre>
<pre><code>## IGRAPH 3de1f0c UNW- 7 10 -- 
## + attr: name (v/c), weight (e/n)
## + edges from 3de1f0c (vertex names):
##  [1] Adam  --Betty   Adam  --Daniel  Adam  --Frank   Betty --Charles
##  [5] Betty --Daniel  Betty --Frank   Daniel--Esther  Daniel--Frank  
##  [9] Esther--Frank   Frank --Gina</code></pre>
<pre class="r"><code>plot(eg, edge.width=E(eg)$weight)</code></pre>
<p><img src="02_dataformats_files/figure-html/unnamed-chunk-15-1.png" width="576" /></p>
<p>###2.3.2 Creating a network from your adjacency matrix</p>
<p>Importing an adjacency matrix written in .csv format is just slightly
trickier. This is because you want R to know that first row is a header
AND the first row contains row names rather than data. You also want R
to recognize this data as a “matrix object”. We can use just one line of
code to do this:</p>
<pre class="r"><code>am=as.matrix(read.csv(&quot;https://dshizuka.github.io/network2018/NetworkWorkshop_SampleData/sample_adjmatrix.csv&quot;, header=T, row.names=1))
am</code></pre>
<pre><code>##         Adam Betty Charles Daniel Esther Frank Gina
## Adam       0     1       0      1      0     4    0
## Betty      1     0       3      1      0     2    0
## Charles    0     3       0      0      0     0    0
## Daniel     1     1       0      0      1     1    0
## Esther     0     0       0      1      0     1    0
## Frank      4     2       0      1      1     0    2
## Gina       0     0       0      0      0     2    0</code></pre>
<p>Now we have our adjacency matrix, and we are ready to convert this
into an igraph object! Note that this is a <em>weighted adjacency
matrix</em>. Note that we are going to add an argument
<code>weighted=T</code> to indicate that the edges have weights. The
results from the code below should look the same as above. We’ll call
this new network <code>g</code>, which will overwrite the previous graph
object of the same name.</p>
<pre class="r"><code>g=graph_from_adjacency_matrix(am, mode=&quot;undirected&quot;, weighted=T)
plot(g, edge.width=E(g)$weight)</code></pre>
<p><img src="02_dataformats_files/figure-html/unnamed-chunk-17-1.png" width="576" /></p>
<p>###2.3.3 Creating a network from group or site associations</p>
<p>There are two common instances when you might make a network from an
affiliation matrix–that is, a matrix in which rows are individuals (or
whatever element will be your node) and columns are ‘groups’ that these
individuals belong to. We often build <strong><em>social
networks</em></strong> out of data on co-membership in groups (flocks,
herds, shoals, pods, etc.) across time and space. Most often, we apply a
‘gambit of the group’–that is, we assume that individuals that occur
together in group are “associated”. Typically, an association index is
calculated using the group membership data. For more detailed tutorial
on this, see <a
href="https://dshizuka.github.io/networkanalysis/networktypes_socialnetworks.html">this
page on social networks</a></p>
<ul>
<li>For in-depth discussion of the pros and cons of the ‘gambit of the
group’ method, see <a
href="https://link.springer.com/article/10.1007/s00265-009-0865-8">Franks
et al. (2010)</a>.</li>
</ul>
<hr />
<p>Next: <a href="03_plots.html">3. Plotting Basics</a></p>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
