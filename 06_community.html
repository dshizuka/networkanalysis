<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Dai Shizuka" />


<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 60px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 65px;
  margin-top: -65px;
}

.section h2 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h3 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h4 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h5 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h6 {
  padding-top: 65px;
  margin-top: -65px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Network Analysis Tutorials</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
<li>
  <a href="tutorials.html">Tutorials</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore"><ol start="6" style="list-style-type: decimal">
<li>Community Structure and Assortment</li>
</ol></h1>
<h4 class="author"><em>Dai Shizuka</em></h4>
<h4 class="date"><em>7/11/2018</em></h4>

</div>

<div id="TOC">
<ul>
<li><a href="#community-structure-in-networks">6.1 Community Structure in Networks</a><ul>
<li><a href="#modularity-and-community-detection">6.1.1 Modularity and Community Detection</a></li>
<li><a href="#community-detection-in-igraph">6.1.1 Community detection in igraph</a></li>
<li><a href="#the-assortatment-coefficient">6.2 The Assortatment Coefficient</a></li>
</ul></li>
</ul>
</div>

<hr />
<div id="community-structure-in-networks" class="section level2">
<h2>6.1 Community Structure in Networks</h2>
<div class="figure">
<img src="https://www.dropbox.com/s/zdwuurj6kujbkdb/Newman2006_figure.png?dl=1" alt="Figure 1: An example of a network with community structure. From Newman 2006-PNAS" />
<p class="caption">Figure 1: An example of a network with community structure. From Newman 2006-PNAS</p>
</div>
<p>One of the ubiquitous properties of networks is that they exhibit <em>community structure</em>, the presence of discrete clusters of nodes that are densely connected, which themselves are only loosely connected to other clusters (Figure 6.1). In ecological contexts, these may be clusters of individuals that form social groups, groups of populations that form cohesive genetic or ecological units, or sets of species that have intimate ecological and evolutionary interactions. The problem is, how do we detect the presence of such <em>clusters</em> or <em>communities</em>, and how can we quantify the degree of community structure?</p>
<div id="modularity-and-community-detection" class="section level3">
<h3>6.1.1 Modularity and Community Detection</h3>
<p>In a series of papers, Mark Newman and colleagues presented a quantitative measure called <strong>modularity</strong>, which quantify the degree to which such clusters are discrete (Girvan &amp; Newman 2002; Newman &amp; Girvan 2004; Newman 2006). The modularity index, <em>Q</em>, is a measure of the proportion of edges that occur within communities , relative to the expected proportion if all edges were placed randomly.</p>
<p><span class="math inline">\(Q = \frac{1}{2m} \left(A_ij-\frac{k_i k_j}{2m}\right)\delta\left(c_i,c_j\right)\)</span></p>
<p>Where <span class="math inline">\(m\)</span> is the total number of edges in a network, <span class="math inline">\(A_ij\)</span> is the adjacency matrix, <span class="math inline">\(k_i\)</span> and <span class="math inline">\(k_j\)</span> are the degrees of node <span class="math inline">\(i\)</span> an <span class="math inline">\(j\)</span>, <span class="math inline">\(c_i\)</span> and <span class="math inline">\(c_j\)</span> refer to the communities to which <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> belong, and <span class="math inline">\(\delta\left(c_i,c_j)\right)\)</span> is the Kroenecker delta function, which equals 1 when <span class="math inline">\(c_i = c_j\)</span> and 0 otherwise. This value theoretically ranges from 0 to 1.</p>
<p>One class of methods for community detection (often called ‘modularity-optimization method’) to find the partitions in the network that assigns nodes into communities such that <span class="math inline">\(Q\)</span> is maximized. The problem, however, is that there are too many possible partitions that can exist in a given network (ranging from 1 to n number of communities, with every possible combination of nodes), and so an exhaustive search is usually not feasible. Thus, modularity-optimization techniques rely on search algorithms that use different approaches (e.g., agglomerative versus divisive methods) with different strengths and weaknesses (we will hight a few below).</p>
<p>One should also be aware that modularity-based methods of community detection is not fool-proof. In particular, there is a well-studied resolution limit to modularity optimization: these methods tend to miss small, well-defined communities when there are other large communities. They also suffer from the basic assumption that each node belongs to just one community. While other community detection methods exist that can overcome some of these shortfalls, they too often have their weaknesses. In short, there is no perfect approach to community detection. Useful references to these debates include Palla et al. (2005), Fortunato (2010), Lancichinetti &amp; Fortunato (2011), and countless others.</p>
</div>
<div id="community-detection-in-igraph" class="section level3">
<h3>6.1.1 Community detection in igraph</h3>
<p>There are several functions available for community detection in <code>igraph</code> and other packages.</p>
<table style="width:94%;">
<colgroup>
<col width="22%" />
<col width="51%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th>Function</th>
<th>Basic Idea</th>
<th>Reference</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>edge.betweenness.community()</code></td>
<td>One of the first in the class of “modularity optimization” algorithms. It is a “divisive” method. Cut the edge with highest edge betweenness, and recalculate. Eventually, you end up cutting the network into different groups.</td>
<td>Newman &amp; Girvan 2004</td>
</tr>
<tr class="even">
<td><code>fastgreedy.community()</code></td>
<td>Hierarchical agglomerative method that is designed to run well in large networks. Creates “multigraphs” where you lump groups of nodes together in the process of agglomeration in order to save time on sparse graphs.</td>
<td>Clauset et al. 2004</td>
</tr>
<tr class="odd">
<td><code>walktrap.community()</code></td>
<td>Uses random walks to calculate distances, and then use agglomerative method to optimize modularity</td>
<td>Pons &amp; Latapy 2005</td>
</tr>
<tr class="even">
<td><code>spinglass.community()</code></td>
<td>This method uses the analogy of the lowest-energy state of a collection of magnets (a so-called spin glass model).</td>
<td>Reichardt &amp; Bornholdt 2006</td>
</tr>
<tr class="odd">
<td><code>leading.eigenvector.community()</code></td>
<td>This is a “spectral partitioning” method. You first define a ‘modularity matrix’, which sums to 0 when there is no community structure. The leading eigenvector of this matrix ends up being useful as a community membership vector.</td>
<td>Newman 2006</td>
</tr>
<tr class="even">
<td><code>label.propagation.community()</code></td>
<td>I have not used this one…</td>
<td>Raghavan et al. 2007</td>
</tr>
<tr class="odd">
<td><code>cluster_louvain()</code></td>
<td>The “Louvain” method, so-called because it was created by a group of researchers at Louvain University in Belgium. Community aggregation</td>
<td>Blondel et al. 2008</td>
</tr>
<tr class="even">
<td><code>rnetcarto::netcarto()</code></td>
<td>Simulated Annealing method. Thought to be useful for smaller networks. Available through ‘rnetcarto’ package (Doulcier 2015).</td>
<td>Guimera &amp; Amaral 2005</td>
</tr>
</tbody>
</table>
</div>
<div id="the-assortatment-coefficient" class="section level3">
<h3>6.2 The Assortatment Coefficient</h3>
<p>One major pattern common to many social networks (and other types of networks) is <em>homophily</em> or <em>assortativity</em>—the tendency for nodes that share a trait to be connected. The assortment coefficient is a commonly used measurement of homophily. It is similar to the modularity index used in community detection, but the assortativity coefficient is used when we know a priori the ‘type’ or ‘value’ of nodes. For example, we can use the assortment coefficient to examine whether discrete node types (e.g., gender, ethnicity, species, etc.) are more or less connected to each other. Assortment coefficient can also be used with “scalar attributes” (i.e., continuously varying traits).</p>
<div class="figure">
<img src="https://www.dropbox.com/s/uljzgbj62x1l5h6/assortment.png?dl=1" alt="Figure 2: Two networks with different patterns of assortment. Node color represents some discrete node value (e.g., male vs. female). Left, an assortative, or homophilous, network. Right, a network with no assortativity." />
<p class="caption">Figure 2: Two networks with different patterns of assortment. Node color represents some discrete node value (e.g., male vs. female). Left, an assortative, or homophilous, network. Right, a network with no assortativity.</p>
</div>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
