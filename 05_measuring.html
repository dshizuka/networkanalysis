<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Dai Shizuka" />


<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Network Analysis Tutorials</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
<li>
  <a href="tutorials.html">Tutorials</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore"><ol start="5" style="list-style-type: decimal">
<li>Measuring Networks</li>
</ol></h1>
<h4 class="author"><em>Dai Shizuka</em></h4>
<h4 class="date"><em>7/11/2018</em></h4>

</div>

<div id="TOC">
<ul>
<li><a href="#centrality-measures-i.e.-node-level-measures">5.1 Centrality Measures (i.e., node-level measures)</a><ul>
<li><a href="#degree-and-strength">5.1.1 Degree and Strength</a></li>
<li><a href="#betweenness">5.1.2 Betweenness</a></li>
<li><a href="#assembling-a-dataset-of-node-level-measures">5.1.3 Assembling a dataset of node-level measures</a></li>
</ul></li>
<li><a href="#network-level-measures">5.2 Network-level measures</a></li>
</ul>
</div>

<hr />
<p>Now that we have a handle on visualizing a network and the basics of relevant types of networks, we will go about the task of quantitatively describing its characteristics. There are multiple levels at which we can measure and describe networks:</p>
<ul>
<li>Node-level</li>
<li>Subcomponent-level</li>
<li>Networklevel</li>
</ul>
<p>Let’s start by loading the sample social network we introduced in <a href="04.1_socialnetworks.html">section 4.1</a>. Here, we are going to be using both the <code>igraph</code> and <code>asnipe</code> packages.</p>
<pre class="r"><code>library(asnipe)
library(igraph)
degree=igraph::degree
betweenness=igraph::betweenness
closeness=igraph::closeness
assoc=as.matrix(read.csv(&quot;https://dshizuka.github.io/networkanalysis/SampleData/Sample_association.csv&quot;, header=T, row.names=1))
gbi=t(assoc) 
mat=get_network(t(assoc), association_index=&quot;SRI&quot;) 
g=graph_from_adjacency_matrix(mat, &quot;undirected&quot;, weighted=T) #create a graph object</code></pre>
<pre class="r"><code># plot the network
set.seed(10)
l=layout_with_fr(g)
plot(g, layout=l, vertex.label=&quot;&quot;, vertex.color=&quot;gold&quot;, edge.color=&quot;slateblue&quot;, edge.width=E(g)$weight*5)</code></pre>
<p><img src="05_measuring_files/figure-html/unnamed-chunk-3-1.png" width="384" /></p>
<div id="centrality-measures-i.e.-node-level-measures" class="section level2">
<h2>5.1 Centrality Measures (i.e., node-level measures)</h2>
<p>Centrality is a general term that relates to measures of a node’s position in the network. There are many such centrality measures, and it can be a daunting task to wade through all of the different ways to measure a node’s importance in the network. Here, we will introduce just a few examples.</p>
<div id="degree-and-strength" class="section level3">
<h3>5.1.1 Degree and Strength</h3>
<p>Let’s start with the most straight-forward centrality metric: <strong>degree centrality</strong>. Degree centrality is simply the <em>number of edges connected to a given node</em>. In a social network, this might mean the number of friends an individual has. We can calculate degree centrality with a simple function:</p>
<pre class="r"><code>degree(g)</code></pre>
<pre><code>## 23820 23726 23831 23763 23772 23770 23771 23777 23774 23860 23779 23773 
##     4     4     4     4     6     8    10     7     8     9     4    11 
## 23862 23857 23871 23853 23732 23734 23756 23759 23768 23758 23781 23815 
##    11     2     3     4     3     1     6     6     6     7     4     4 
## 23809 
##     4</code></pre>
<p>Let’s visualize what this means by varying the node sizes proportional to degree centrality.</p>
<pre class="r"><code>set.seed(10)
de=igraph::degree(g)
plot(g, vertex.label=&quot;&quot;, vertex.color=&quot;gold&quot;, edge.color=&quot;slateblue&quot;, vertex.size=de*2, edge.width=E(g)$weight*5)</code></pre>
<p><img src="05_measuring_files/figure-html/unnamed-chunk-5-1.png" width="384" /></p>
<p>In weighted networks, we can also <strong>node strength</strong>, which is the sum of the weights of edges connected to the node. Let’s calculate node strength and plot the node sizes as proportional to these values.</p>
<pre class="r"><code>set.seed(10)
st=graph.strength(g)
plot(g,  vertex.label=&quot;&quot;, vertex.color=&quot;gold&quot;, edge.color=&quot;slateblue&quot;, edge.width=E(g)$weight*5, vertex.size=st*5)</code></pre>
<p><img src="05_measuring_files/figure-html/unnamed-chunk-6-1.png" width="384" /></p>
<p>Compare the relative node sizes when plotting by <strong>degree</strong> vs. <strong>strength</strong>. What differences do you notice?</p>
</div>
<div id="betweenness" class="section level3">
<h3>5.1.2 Betweenness</h3>
<p>Let’s now do the same for <strong>betweenness centrality</strong>, which is defined as <em>the number of geodesic paths (shortest paths) that go through a given node</em>. Nodes with high betweenness might be influential in a network if, for example, they capture the most amount of information flowing through the network because the information tends to flow through them. Here, we use the normalized version of betweenness.</p>
<pre class="r"><code>be=betweenness(g, normalized=T)
plot(g,  vertex.label=&quot;&quot;, vertex.color=&quot;gold&quot;, edge.color=&quot;slateblue&quot;, vertex.size=be*50, edge.width=E(g)$weight*5)</code></pre>
<p><img src="05_measuring_files/figure-html/unnamed-chunk-7-1.png" width="384" /></p>
<p>You can see that there are three nodes that have qualitatively higher betweenness values than all other nodes in the network. One way to interpret this is that these are nodes that tend to act as “bridges” between different clusters of nodes in the network (but of course, this is only sample data).</p>
<p>What does this say about the importance of these nodes? Well, that depends on the network and the questions–in particular how you might quantify ‘importance’ in your network.</p>
<p>Here’s a short list of some commonly-used centrality measures:</p>
<table style="width:86%;">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th>Centrality Measure</th>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>degree</td>
<td><code>degree()</code></td>
<td>Number of edges connected to node</td>
</tr>
<tr class="even">
<td>strength</td>
<td><code>graph.strength()</code></td>
<td>Sum of edge weights connected to a node (aka <em>weighted degree</em>)</td>
</tr>
<tr class="odd">
<td>betweenness</td>
<td><code>betweenness()</code></td>
<td>Number of geodesic paths that go through a given node</td>
</tr>
<tr class="even">
<td>closeness</td>
<td><code>closeness()</code></td>
<td>Number of steps required to access every other node from a given node</td>
</tr>
<tr class="odd">
<td>eigenvector centrality</td>
<td><code>eigen_centrality()</code></td>
<td>Values of the first eigenvector of the graph adjacency matrix. The values are high for vertices that are connected to many other vertices that are, in turn, connected many others, etc.</td>
</tr>
</tbody>
</table>
</div>
<div id="assembling-a-dataset-of-node-level-measures" class="section level3">
<h3>5.1.3 Assembling a dataset of node-level measures</h3>
<p>So now we know the basics of how to get centrality measures. For data analysis, we will likely want to measure and compare measures of node centrality with other traits. This will require putting together a dataframe that combines vertex attributes and centrality measures.</p>
<p>Let’s say we want to assemble a dataset of node centrality for our sparrow network. Let’s use the three centrality measures we already introduced:</p>
<pre class="r"><code>names=V(g)$name
de=degree(g)
st=graph.strength(g)
be=betweenness(g, normalized=T)


#assemble dataset
d=data.frame(node.name=names, degree=de, strength=st, betweenness=be) 
head(d) #display first 6 lines of data</code></pre>
<pre><code>##       node.name degree strength betweenness
## 23820     23820      4 3.333333   0.0000000
## 23726     23726      4 3.333333   0.0000000
## 23831     23831      4 3.333333   0.0000000
## 23763     23763      4 3.333333   0.0000000
## 23772     23772      6 1.333333   0.1123188
## 23770     23770      8 2.683333   0.0000000</code></pre>
<p>Let’s plot the relationship between degree and strength</p>
<pre class="r"><code>plot(strength~degree, data=d)</code></pre>
<p><img src="05_measuring_files/figure-html/unnamed-chunk-9-1.png" width="384" /></p>
<p>Obviously, these are correlated, since strength is simply the weighted version of degree.</p>
<p>How about the relationship between betweenness and strength?</p>
<pre class="r"><code>plot(betweenness~strength, data=d)</code></pre>
<p><img src="05_measuring_files/figure-html/unnamed-chunk-10-1.png" width="384" /></p>
<p>These are not well correlated, since they describe something different…</p>
</div>
</div>
<div id="network-level-measures" class="section level2">
<h2>5.2 Network-level measures</h2>
<p>Size and density Let’s start by getting some basic information for the network, such as the number of nodes and edges. There are a couple of functions to help you extract this information without having to look it up in the “object summary” (e.g., <code>summary(g)</code>). Using these functions, you can store this information as separate objects, e.g., <em>n</em> for # nodes and <em>m</em> for # edges.</p>
<pre class="r"><code>n=vcount(g)
m=ecount(g)
n</code></pre>
<pre><code>## [1] 25</code></pre>
<pre class="r"><code>m</code></pre>
<pre><code>## [1] 70</code></pre>
<p>Since we now have the network size and the number of edges, we can calculate the density of the network. The definition of network density is:</p>
<p>density = [# edges that exist] / [# edges that are possible]</p>
<p>In an undirected network with no loops, the number of edges that are possible is exactly the number of dyads that exist in the network. In turn, the number of dyads is <span class="math inline">\(\frac {n(n−1)}{2}\)</span> where <em>n</em> = number of nodes. Withthis information, we can calculate the density with the following:</p>
<pre class="r"><code>dyads=n*(n-1)/2
density=m/dyads
density</code></pre>
<pre><code>## [1] 0.2333333</code></pre>
<p>Of course, there is a pre-packaged function for calculating density, called <code>edge_density()</code>:</p>
<pre class="r"><code>edge_density(g)</code></pre>
<pre><code>## [1] 0.2333333</code></pre>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
