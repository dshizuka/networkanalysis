---
title: "11. Intro to Diffusion on Networks"
author: "Dai Shizuka"
date: "7/12/2018"
output: 
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: false
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(fig.width=5, fig.height=4.5, message=F) 
set.seed(2)
```


Packages you will need for this tutorial:
```{r}
library(igraph)
```

-----

#11.1 Diffusion/Flow/Transmission through a network

One of the assumptions of network theory is that the connections between elements in a system matter to the function/property of the system and/or the individual elements within the system. One way in which such connections matters is that they can facilitate the flow of *something* through this system. Some examples include:

* Electricity through an electric grid
* Bits of information through the internet
* Vehicles/individuals moving through a transportation network
* Information through social networks
* Disease through contact networks
* Modification of social strategies through competition networks

<br>

##11.2 Simulation of asocial changes in state (e.g., asocial learning)

Let’s first consider a situation where each individual in a social network has an inherent probability to adopt the innovation at any given time.


Now, we will set the initial ‘innovation adoption’ status for all individuals (all initially 0) and also create an empty list where we will store the identities of individuals that adopt at each time step. We then start a for loop that has several steps:

Step 1: Set the probability of adoption to 0 if the individual has already adopted (can’t re-adopt the innovation).

Step 2: Flip a coin based on the probabilities established above and determine if the individual adopts the innovation or not.

Step 3: Change the status of the individuals that did adopt.

Step 4: Save the identities of the new adopters.

Repeat Steps 1 though 4 x20 timess

```{r}
set.seed(4)
n=100
x=0.1
g=erdos.renyi.game(n, p=0.05)
V(g)$status=0 #the 'innovation adoption status' for each individual. All initially 0.

adopters=sample(c(1,0),n, prob=c(x, 1-x), replace=T) #based on the probabilities, flip a coin and determine if the individual adopted or not.

V(g)$status[which(adopters==1)]=1 #change status of new adopters adopt.list[[j]]=which(adopters==1) #save the identities of adopters for that time step

plot(g, vertex.label="", vertex.color=c("darkgray", "red")[V(g)$status+1], vertex.size=8)
```

```{r}
t=20
new.adopt.list=list(0) #empty list t=20
for(j in 1:t){
  adopters=sample(c(1,0), n, prob=c(x, 1-x), replace=T)
  new.adopt.list[[j]]=which(V(g)$status==0&adopters==1) #save the identities of adopters for that timestep
  V(g)$status[which(adopters==1)]=1
  
}
new.adopt.list
```

```{r}
adopt.cumulative=list()
for(i in 1:t){
  adopt.cumulative[[i]]=unlist(new.adopt.list[1:i])
}
adopt.cumulative
```

```{r}
layout(matrix(1:20, byrow=T, nrow=5))
par(mar=c(1,1,1,1))
for(i in 1:t){
  v.col=1:n %in% adopt.cumulative[[i]]+1
  plot(g, vertex.label="", vertex.color=c("darkgray", "red")[v.col], main=paste("Time",i))
}
```

```{r}
n.adopt.asocial=sapply(new.adopt.list, length) #for each time step, count the number of adopters.
cumulative.asocial=cumsum(n.adopt.asocial)
plot(cumulative.asocial, type="b", las=1, ylab="Cumulative number of nodes adopted", xlab="Time")
```

##11.3 Simulation the social transmission of *whatever* state in a random graph

First, we will create an Erdös-Renyí Random Graph with 100 nodes and p = 0.1
```{r}
library(igraph)
set.seed(4)
n=100
g=erdos.renyi.game(n, p=0.05) #create a Erdos-Renyi Random Graph with uniform edge probability = 0.1
l = layout_with_fr(g)
plot(g, vertex.label="", vertex.size=8, vertex.color="darkgray", layout=l)
```

Next, we will create a vertex attribute called "state". Everyone will start with state = 1. Then, we will randomly pick 2 nodes who will have state = 2
```{r}
V(g)$state=0 # Create a vertex attribute for adoption status. 1 if the node has adopted the innovation. 0 if not.
seed=sample(V(g),2) #select 2 innovators
V(g)$state[seed]=1 #These 'seed' individuals get a status of 1 at the beginning.
plot(g, vertex.label="", vertex.size=8, vertex.color=c("darkgray", "red")[V(g)$state+1], layout=l)
```

Now, we will set a "social transmission" parameter, $s$.
You can think of this as the linear increase in the probability that an individual will take on a new "state" (e.g., learn a new foraging strategy or get infected by a disease) when it has a 'neighbor' that has that state. Since it's a probabilty 0 ≤ $s$ ≤ 1.

Let's set s = 0.1 for now:

```{r}
s = 0.1
```

Now we will simulate 20 time steps of the spread of this "state".

```{r}
t=20 #time steps to run the simulation
adopt.list=list(0) #empty list 

for (j in 1:t){
nei.adopt=sapply(V(g), function(x) sum(V(g)$state[neighbors(g,x)]))
p=(1-exp(-s*nei.adopt))*abs(V(g)$state-1) #here, we multiply the probabilities by 0 if node is already adopted, and 1 if not yet adopted
adopters=sapply(p, function(x) sample(c(1,0), 1, prob=c(x, 1-x)))
V(g)$state[which(adopters==1)]=1
adopt.list[[j]]=which(adopters==1)
}
```

```{r}
n.adopt.social=sapply(adopt.list, length) #for each time step, count the number of adopters.
cumulative.social=cumsum(n.adopt.social)
plot(cumulative.social, type="b", las=1, ylab="Cumulative number of nodes adopted", xlab="Time")
```

```{r}
adopt.list
adopt.cumulative=list()
for(i in 1:t){
  adopt.cumulative[[i]]=unlist(adopt.list[1:i])
}

```


```{r, fig.width=6, fig.height=5}
layout(matrix(1:20, byrow=T, nrow=5))
par(mar=c(1,1,1,1))
for(i in 1:t){
  v.col=1:n %in% adopt.cumulative[[i]]+1
  plot(g, vertex.label="", vertex.color=c("darkgray", "red")[v.col], main=paste("Time",i))
}
```


