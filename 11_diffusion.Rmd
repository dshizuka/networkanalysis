---
title: "11. Intro to Diffusion on Networks"
author: "Dai Shizuka"
date: "7/12/2018"
output: 
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: false
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(fig.width=5, fig.height=4.5, message=F) 
set.seed(2)
```


Packages you will need for this tutorial:
```{r}
library(igraph)
```

-----

#11.1 Diffusion/Flow/Transmission through a network

One of the assumptions of network theory is that the connections between elements in a system matter to the function/property of the system and/or the individual elements within the system. One way in which such connections matters is that they can facilitate the flow of *something* through this system. Some examples include:

* Electricity through an electric grid
* Bits of information through the internet
* Vehicles/individuals moving through a transportation network
* Information through social networks
* Disease through contact networks
* Modification of social strategies through competition networks

<br>

One of the classical theories on social spread is that the accumulation of individuals (nodes) that take on a new state (e.g., an innovation) takes on different pattern when the spread is due to asocial processes (e.g., everyone innovates on their own) versus social processes (e.g., innovation spreads through social transmission).

![Figure showing classical predictions of asocial versus social spread of innovations. From [Franz & Nunn (2009)](http://rspb.royalsocietypublishing.org/content/276/1663/1829).](./assets/images/FranzNunn2009.png)

Here, let's explore this paradigm by actually simulating the spread of innovation due to asocial or social processes. 

##11.2 Simulation of asocial changes in state (e.g., asocial learning)

Let’s first consider a situation where each individual in a social network has an inherent probability to adopt the innovation at any given time. 

First, we will make a random graph consisting of 100 nodes. We will set the initial ‘innovation adoption’ status for all individuals (all initially 0). 

```{r}
set.seed(4)
n=100
g=erdos.renyi.game(n, p=0.05)
V(g)$status=0 #the 'innovation adoption status' for each individual. All initially 0.
```

Let's plot this random graph. While we're at it, we will save the layout so that we can use it for all the plots of this network later.
```{r}
l=layout_with_fr(g)
plot(g, vertex.label="", vertex.size=8, vertex.color="darkgray", layout=l)
```

Now, we will set the 'asocial learning' parameter, $x$ to be 0.1. This is the probability that any given individual will come up with the innovation--e.g., how to forage for a new prey item. 

```{r}
x=0.1
```

Let's run one practice run of how this will work. In one time step, we flip a coin for each individual whether or not they will adopt the innovation. 
Based on the coin flip, we will convert the status of the individual to 1 if they learned the innovation in that time step:

```{r}
adopt=sample(c(1,0),n, prob=c(x, 1-x), replace=T) #based on the probabilities, flip a coin and determine if the individual adopted or not.

V(g)$status[which(adopt==1)]=1 #change status of new adopters adopt.list[[j]]=which(adopters==1) #save the identities of adopters for that time step

plot(g, vertex.label="", vertex.color=c("darkgray", "red")[V(g)$status+1], vertex.size=8, layout=l)
```

Now, we will repeat this simulation for 20 time steps. Here, we need to consider that any given individual can only adopt an innovation once (it can't go back). If you're thinking about this in terms of disease, it's like an 'SI model' in which individuals do not recover or go back to a susceptible state. In practical terms, this means that we will just ignore coin flips for individuals whose status = 1.

```{r}
t=20
adopt.list=list(0) #empty list t=20
g.time=list()
for(j in 1:t){
  adopt=sample(c(1,0), n, prob=c(x, 1-x), replace=T) #coin flip
  V(g)$status[which(adopt==1)]=1
  g.time[[j]]=g
}
```

```{r, eval=T}
sapply(g.time, function(x) V(x)$status) 
```

Ok, now let's make a cumulative list of who
```{r, eval=F}
adopt.cumulative=list()
for(i in 1:t){
  adopt.cumulative[[i]]=unlist(adopt.list[1:i])
}
```

```{r}
layout(matrix(1:20, byrow=T, nrow=5))
par(mar=c(1,1,1,1))
for(i in 1:t){
  v.col=c("darkgray", "red")[V(g.time[[i]])$status+1]
  plot(g.time[[i]], vertex.label="", vertex.color=c("darkgray", "red")[v.col], layout=l, main=paste("Time",i))
}
```

```{r, eval=F}
n.adopt.asocial=sapply(adopt.list, length) #for each time step, count the number of adopters.
cumulative.asocial=cumsum(n.adopt.asocial)
plot(cumulative.asocial, type="b", las=1, ylab="Cumulative number of nodes adopted", xlab="Time")
```

##11.3 Simulation the social transmission of *whatever* state in a random graph

First, we will create an Erdös-Renyí Random Graph with 100 nodes and p = 0.1
```{r}
library(igraph)
set.seed(4)
n=100
g=erdos.renyi.game(n, p=0.05) #create a Erdos-Renyi Random Graph with uniform edge probability = 0.1
plot(g, vertex.label="", vertex.size=8, vertex.color="darkgray", layout=l)
```

Next, we will create a vertex attribute called "state". Everyone will start with state = 1. Then, we will randomly pick 2 nodes who will have state = 2
```{r}
V(g)$state=0 # Create a vertex attribute for adoption status. 1 if the node has adopted the innovation. 0 if not.
seed=sample(V(g),2) #select 2 innovators
V(g)$state[seed]=1 #These 'seed' individuals get a status of 1 at the beginning.
plot(g, vertex.label="", vertex.size=8, vertex.color=c("darkgray", "red")[V(g)$state+1], layout=l)
```

Now, we will set a "social transmission" parameter, $s$.
You can think of this as the linear increase in the probability that an individual will take on a new "state" (e.g., learn a new foraging strategy or get infected by a disease) when it has a 'neighbor' that has that state. Since it's a probabilty 0 ≤ $s$ ≤ 1.

Let's set s = 0.1 for now:

```{r}
s = 0.1
```

Now we will simulate 20 time steps of the spread of this "state".

```{r}
t=20 #time steps to run the simulation
adopt.list=list(0) #empty list 

for (j in 1:t){
nei.adopt=sapply(V(g), function(x) sum(V(g)$state[neighbors(g,x)]))
p=(1-exp(-s*nei.adopt))*abs(V(g)$state-1) #here, we multiply the probabilities by 0 if node is already adopted, and 1 if not yet adopted
adopters=sapply(p, function(x) sample(c(1,0), 1, prob=c(x, 1-x)))
V(g)$state[which(adopters==1)]=1
adopt.list[[j]]=which(adopters==1)
}
```

```{r}
n.adopt.social=sapply(adopt.list, length) #for each time step, count the number of adopters.
cumulative.social=cumsum(n.adopt.social)
plot(cumulative.social, type="b", las=1, ylab="Cumulative number of nodes adopted", xlab="Time")
```

```{r}
adopt.list
adopt.cumulative=list()
for(i in 1:t){
  adopt.cumulative[[i]]=unlist(adopt.list[1:i])
}

```


```{r, fig.width=6, fig.height=5}
layout(matrix(1:20, byrow=T, nrow=5))
par(mar=c(1,1,1,1))
for(i in 1:t){
  v.col=1:n %in% adopt.cumulative[[i]]+1
  plot(g, vertex.label="", vertex.color=c("darkgray", "red")[v.col], layout=l, main=paste("Time",i))
}
```


